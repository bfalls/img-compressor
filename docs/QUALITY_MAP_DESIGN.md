# Quality Map (Content-Aware Quantization) Design Notes

## Current pipeline touchpoints
- **CLI + orchestration:** `src/main.cu` parses `--input`, `--output`, `--quality`, and `--compare` before dispatching to CPU/GPU compression entry points.
- **CPU quantization site:** `compress_channel_cpu` in `src/compressor_cpu.cpp` performs 8x8 DCT, then quantizes/dequantizes with `qtbl[64]` inside the nested block loop.
- **GPU quantization site:** `k_dct8x8_quant_idct` in `src/compressor_gpu.cu` applies quantization via `d_qLuma` inside the kernel prior to IDCT. `compress_channel_gpu` owns kernel launch parameters.

## Proposed quality map plumbing
- **Importance computation module:** add `include/saliency.hpp` + `src/saliency.cpp` with a CPU implementation `std::vector<float> compute_block_importance(const ImageRGB& img);` that returns per-8x8-block scores in raster order (size `(ceil(w/8) * ceil(h/8))`).
- **Config surface:** introduce a small POD struct (e.g., `struct QualityMapConfig`) threaded from `main.cu` into CPU/GPU paths to carry `enabled/strength/minScale/maxScale/debugPath`.
- **Application point:** convert importance `s` -> scale `m` -> multiplier `a = 1/m`, then scale DCT coefficients *before* quantization:
  - CPU: inside `compress_channel_cpu` block loop, multiply each `coeff[u][v]` by the per-block factor (reuse for RGB; consider reduced strength for chroma later).
  - GPU: upload per-block multipliers to device memory and sample in `k_dct8x8_quant_idct` using block indices.

## Debug outputs (v1)
- Optional heatmap/block CSV behind a `--quality-map-debug <path>` flag; generated by the CPU saliency module to keep output deterministic.
